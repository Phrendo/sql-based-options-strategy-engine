USE [SPX_RAW_OPTIONS]
GO
/****** Object:  Schema [IO]    Script Date: 8/2/2024 12:23:15 PM ******/
CREATE SCHEMA [IO]
GO
/****** Object:  Schema [SPX]    Script Date: 8/2/2024 12:23:15 PM ******/
CREATE SCHEMA [SPX]
GO
/****** Object:  Table [SPX].[EM]    Script Date: 8/2/2024 12:23:15 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [SPX].[EM](
	[T] [datetime2](0) NULL,
	[EM] [decimal](9, 2) NULL
) ON [PRIMARY]
GO
/****** Object:  Table [SPX].[OHLC_SPX_DAY]    Script Date: 8/2/2024 12:23:15 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [SPX].[OHLC_SPX_DAY](
	[D] [date] NULL,
	[O] [decimal](8, 2) NULL,
	[H] [decimal](8, 2) NULL,
	[L] [decimal](8, 2) NULL,
	[C] [decimal](8, 2) NULL
) ON [PRIMARY]
GO
/****** Object:  Table [SPX].[OPT]    Script Date: 8/2/2024 12:23:15 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [SPX].[OPT](
	[OPT_ID] [int] IDENTITY(1,1) NOT NULL,
	[Strike] [smallint] NOT NULL,
	[CP] [smallint] NOT NULL,
	[Expiry] [date] NOT NULL,
 CONSTRAINT [PK_OPT] PRIMARY KEY CLUSTERED 
(
	[OPT_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [CON_COLS_OPT] UNIQUE NONCLUSTERED 
(
	[Strike] ASC,
	[CP] ASC,
	[Expiry] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [SPX].[OPTM]    Script Date: 8/2/2024 12:23:15 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [SPX].[OPTM](
	[OPT_ID] [int] NULL,
	[T] [datetime2](0) NULL,
	[O] [decimal](9, 2) NULL
) ON [PRIMARY]
GO
/****** Object:  Table [SPX].[UL]    Script Date: 8/2/2024 12:23:15 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [SPX].[UL](
	[T] [datetime2](0) NOT NULL,
	[Mark] [numeric](20, 2) NOT NULL,
 CONSTRAINT [PK_VERT] PRIMARY KEY CLUSTERED 
(
	[T] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  StoredProcedure [SPX].[SP_PROCESS_EM_DATA]    Script Date: 8/2/2024 12:23:15 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:		BW
-- Create date: 03/29/2024
-- Description:	Creates a second by second table of SPX 0 DTE options Expected moves
-- =============================================
CREATE PROCEDURE [SPX].[SP_PROCESS_EM_DATA]
@DD DATE
AS
BEGIN

	SET NOCOUNT ON;

	--EXEC SPX_RAW_OPTIONS.SPX.SP_PROCESS_EM_DATA
	--TO VERIFY THE DATA: SELECT CAST(T AS DATE) D, COUNT(*) Cnt FROM SPX_RAW_OPTIONS.SPX.EM WHERE EM IS NOT NULL gROUP BY CAST(T AS DATE) ORDER BY CAST(T AS DATE)
	--RELIES ON THE OPT AND UL JOBS TO BE RAN FIRST

	--- THIS IS A BIT COMPLICATED, BUT ITS BEEN VETTED THOROUGHLY.  THIS USES THE TASTY DATA TO CREATE A TABLE OF
	--- EXPECTED MOVES FOR EACH AND EVERY SECOND OF THE DATA.  THE SECOND DATA IS GENERATED ON ITS OWN FIRST THING.
	--- THE CODE USES NEAREST NEIGHBOR TO FILL IN ANY BLANKS. WE USE A COUPLE OF TEMP TABLES ;-)

	--DELETE FROM SPX_RAW_OPTIONS.SPX.EM WHERE EM IS NULL

	DECLARE	@D DATE = @DD, @DTE INT = 0

	IF ((SELECT COUNT(*) FROM SPX_RAW_OPTIONS.SPX.EM WHERE CAST(T AS DATE) = @D)=0)
	BEGIN

		DROP TABLE IF EXISTS #ATMS
		DROP TABLE IF EXISTS #ATMIDS
		DROP TABLE IF EXISTS #ATMRES
		DROP TABLE IF EXISTS #EM
		DROP TABLE IF EXISTS #FINAL_TABLE
		DROP TABLE IF EXISTS #NONDUPE
		DROP TABLE IF EXISTS #NEAREST_NEIGH

		--- WE need ATM so we can match it to the Options to create a price. --- WE ARE GETTING THIS FIRST TO MAKE SURE WE HAVE ANY DATA
		SELECT *, CAST(ROUND(Mark/5,0)*5 AS INT) ATM INTO #ATMS FROM SPX_RAW_OPTIONS.SPX.UL WHERE CAST(T AS DATE) = @D

		IF ((SELECT COUNT(*) FROM SPX_RAW_OPTIONS.SPX.EM WHERE CAST(T AS DATE) = @D) <> 23401) -- This is how many seconds in the trade day.
			AND ((SELECT COUNT(*) FROM #ATMS)>2000) -- Can prob adjust this at some point for half days
			AND ((SELECT COUNT(*) FROM SPX_RAW_OPTIONS.SPX.OHLC_SPX_DAY WHERE D = @D)>0)
		BEGIN

			DECLARE @Expirey DATE = DATEADD(DAY,@DTE,@D), @OPT_ID INT, @StartTime TIME(0) = '06:30', @EndTime TIME(0) = '13:00'

			-- THIS SECOND SIMPLY CREATES A DATETIME2(0) GRID FOR THE DAY
			DECLARE @StartDateTime DATETIME2(0) = CAST(@D AS DATETIME) + CAST(@StartTime AS DATETIME), @EndDateTime DATETIME2(0) = CAST(@D AS DATETIME) + CAST(@EndTime AS DATETIME)
			;WITH CTE_Seconds AS (SELECT @StartDateTime T UNION ALL SELECT DATEADD(SECOND, 1, T) FROM CTE_Seconds WHERE T < @EndDateTime)
			SELECT T, CAST(NULL AS DECIMAL(9,2)) EM INTO #FINAL_TABLE FROM CTE_Seconds OPTION (MAXRECURSION 0);

			---- GRAB THE OPT IDS ONE PUT ONE CALL PER T
			SELECT Q.T, ATM, Mark, P.OPT_ID PID, C.OPT_ID CID INTO #ATMIDS
			FROM #ATMS Q
			LEFT JOIN SPX_RAW_OPTIONS.SPX.OPT P ON P.Strike=Q.ATM AND P.Expiry = @Expirey AND P.CP = -1
			LEFT JOIN SPX_RAW_OPTIONS.SPX.OPT C ON C.Strike=Q.ATM AND C.Expiry = @Expirey AND C.CP =  1
			WHERE P.OPT_ID IS NOT NULL AND C.OPT_ID IS NOT NULL

			----- I SIMPLIFIED THIS SINCE I AM ONLY USING 0 DTE
			SELECT A.T, (PP.O+CP.O) EM INTO #ATMRES FROM #ATMIDS A
			LEFT JOIN SPX_RAW_OPTIONS.SPX.OPTM PP ON PP.OPT_ID=PID AND PP.T = A.T
			LEFT JOIN SPX_RAW_OPTIONS.SPX.OPTM CP ON CP.OPT_ID=CID AND CP.T = A.T
			ORDER BY A.T ASC

			---- THIS GETS EVERY DATETIME AND ONLY EM MATCHES -- LEAVES SEVERAL NULLS IN EM, NO NULLS IN DATETIME
			SELECT T, EM INTO #NONDUPE FROM (
				SELECT A.T, B.EM, ROW_NUMBER() OVER(PARTITION BY A.T ORDER BY B.T, B.EM) Rn FROM #FINAL_TABLE A
				LEFT JOIN #ATMRES B ON B.T=A.T
			) Z WHERE Z.Rn = 1

			UPDATE A SET A.Em=B.EM FROM #FINAL_TABLE A
			LEFT JOIN #NONDUPE B ON B.T=A.T
			WHERE B.Em IS NOT NULL

			---- Now we find nearest neighbor
			SELECT * INTO #NEAREST_NEIGH FROM
			(SELECT T FROM #FINAL_TABLE WHERE EM IS NULL) A
			CROSS APPLY (SELECT TOP 1 EM FROM #ATMRES Z WHERE EM IS NOT NULL ORDER BY ABS(DATEDIFF(SECOND, A.T, Z.T)) ASC) B

			UPDATE A SET T=A.T, EM=B.EM FROM #FINAL_TABLE A
			LEFT JOIN #NEAREST_NEIGH B ON B.T=A.T
			WHERE B.EM IS NOT NULL

			INSERT INTO SPX_RAW_OPTIONS.SPX.EM
			SELECT * FROM #FINAL_TABLE A
			WHERE T NOT IN (SELECT T FROM SPX_RAW_OPTIONS.SPX.EM)
			ORDER BY T ASC

		END
	END


END
GO
/****** Object:  StoredProcedure [SPX].[SP_PROCESS_OHLC_SPX_DAY]    Script Date: 8/2/2024 12:23:15 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

-- =============================================
-- Author:		BW
-- Create date: 03/29/2024
-- Description:	OHLC_SPX_DAY
-- =============================================
CREATE PROCEDURE [SPX].[SP_PROCESS_OHLC_SPX_DAY]
@D DATE
AS
BEGIN
	SET NOCOUNT ON;

	--DECLARE @D DATE = '2024-03-01'

	IF ((SELECT COUNT(*) FROM SPX_RAW_OPTIONS.SPX.OHLC_SPX_DAY WHERE D = @D)=0)
	BEGIN

		DROP TABLE IF EXISTS #D
		SELECT CAST(Dt AS DATE) D, O, H, L, C INTO #D FROM UBU.OPT.HISTORIC.DAY WHERE CAST(dt AS DATE) = @D AND Sym = 'SPX'
		
		INSERT INTO SPX_RAW_OPTIONS.SPX.OHLC_SPX_DAY
		SELECT A.* FROM #D A
		LEFT JOIN SPX_RAW_OPTIONS.SPX.OHLC_SPX_DAY B ON B.D=A.D
		WHERE B.D IS NULL

		INSERT INTO SPX_RAW_OPTIONS.SPX.OHLC_SPX_DAY
		SELECT A.Dt, A.O, A.H, A.L, A.C FROM Historic.DATA.DAY_SPX A
		LEFT JOIN SPX_RAW_OPTIONS.SPX.OHLC_SPX_DAY B ON B.D=A.Dt
		WHERE B.D IS NULL AND Dt =  @D

	END

END
GO
/****** Object:  StoredProcedure [SPX].[SP_PROCESS_OPTIONS_DATA]    Script Date: 8/2/2024 12:23:15 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:		BW
-- Create date: 03/29/2024
-- Description:	Raw Options Data into Structure Options Objects and Prices
-- =============================================
CREATE PROCEDURE [SPX].[SP_PROCESS_OPTIONS_DATA]
@D DATE
AS
BEGIN
	SET NOCOUNT ON;
	-------========================== THIS HAS BEEN UPDATED FOR THE NEW SPX_RAW_OPTIONS SYSTEM 6/21/24

	--DECLARE @D DATE = '2024-06-24'

	IF ((SELECT COUNT(*) FROM SPX_RAW_OPTIONS.SPX.OPT WHERE Expiry = @D)=0)
	BEGIN

		--=========== FIRST WE GRAB THE OPTS FOR THE DAY (NOTE THIS WILL RUN RIGHT AFTER MARKET SO THE OPT DATA SHOULD BE COMPLETE)
		DROP TABLE IF EXISTS #FRESH_OPTS
		SELECT * INTO #FRESH_OPTS FROM UBU.SPX_OPT.SPX.OPT WHERE Expiry = @D

		--=========== NEXT WE PUSH THIS UNIQUE DATA INTO LOCAL OPT (IM USING THE JOIN, BUT THERE SHOULD BE NO REASON TO EVER HAVE A DUPE)
		INSERT INTO SPX_RAW_OPTIONS.SPX.OPT (OPT_ID, Strike, CP, Expiry)
		SELECT A.* FROM #FRESH_OPTS A
		LEFT JOIN SPX_RAW_OPTIONS.SPX.OPT B ON B.OPT_ID=A.OPT_ID AND B.Strike=A.Strike AND B.Expiry=A.Expiry
		WHERE B.OPT_ID IS NULL

		--=========== THEN WE INSERT THE OPTM FROM UBU OPTM
		DROP TABLE IF EXISTS #FRESH_OPTMS
		SELECT * INTO #FRESH_OPTMS FROM UBU.SPX_OPT.SPX.OPTM WHERE CAST(T AS DATE) = @D

		INSERT INTO SPX_RAW_OPTIONS.SPX.OPTM (OPT_ID, T, O)
		SELECT A.* FROM #FRESH_OPTMS A
		LEFT JOIN SPX_RAW_OPTIONS.SPX.OPTM B ON B.OPT_ID=A.OPT_ID AND B.T=A.T
		WHERE B.OPT_ID IS NULL

	END
END
GO
/****** Object:  StoredProcedure [SPX].[SP_PROCESS_SPXUL_DATA]    Script Date: 8/2/2024 12:23:15 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:		BW
-- Create date: 03/29/2024
-- Description:	Raw UL Data
-- =============================================
CREATE PROCEDURE [SPX].[SP_PROCESS_SPXUL_DATA]
@D DATE
AS
BEGIN
	SET NOCOUNT ON;

	--DECLARE @D DATE = '2024-06-20'

	IF ((SELECT COUNT(*) FROM SPX_RAW_OPTIONS.SPX.UL WHERE CAST(T AS DATE) = @D)=0)
	BEGIN

		DROP TABLE IF EXISTS #UL
		SELECT * INTO #UL FROM UBU.SPX_OPT.SPX.UL WHERE CAST(T AS DATE) = @D

		-- INSERTS UNIQUE SECOND LEVEL QUOTES
		INSERT INTO SPX_RAW_OPTIONS.SPX.UL
		SELECT A.* FROM
		(
			SELECT CAST(T AS DATETIME2(0)) T, MAX(Mark) Mark 
			FROM #UL
			WHERE CAST(T AS TIME(0)) BETWEEN '06:30' AND '13:00'
			GROUP BY CAST(T AS DATETIME2(0))
		) A
		LEFT JOIN SPX_RAW_OPTIONS.SPX.UL B ON B.T=A.T AND B.Mark=A.Mark
		WHERE B.T IS NULL

	END

END
GO
